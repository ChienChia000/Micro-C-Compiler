/* Definition section */
%{
	#include <stdio.h>
	#include <stdlib.h>

	#include "y.tab.h"	/* header file generated by bison */
	extern YYSTYPE yylval; //YYSTYPE
	extern int currentScope;
	extern void dump_symbol(int currentScope);
	extern char* sementicErrorList[4];
	void keepScan();

	char buf[256];
	char syntaxErrorLine[256];
	int dumpOrNot=0;
	int elseDump=0;
	int dumpSementic=0;
	int dumpSyntax=0;
	int dealCOMMENT=0;
	/* This macro is used to record code line */
	#define CONCAT { strncat(buf, yytext, 256 - strlen(buf) - 1); }

	char c;
	char temp;
	char* Q;
	int flag=0;
	int flagId=0;
	int numLine(char fileName);
	int line=0;
%}

/* Define regular expression label */

letter [a-zA-Z]
digit [0-9]
id {letter}+({letter}|{digit})*
Inumber {digit}+
Fnumber ([0-9]*[.])?[0-9]+
CComment "/*"([^*]|\*+[^*/])*"*/"
CppComment "//"({letter}|{digit}|" ")*
String "\""(.)*"\""

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%
" "		{
			//printf("%s", yytext);
			strcat(buf, yytext);
		}
"+" 		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return ADD;
		}
"-"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return SUB;
		}
"*"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return MUL;
		}
"/"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return DIV;
		}
"%"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return MOD;
		}
"++"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return INC;
		}
"--"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return DEC;
		}

">"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return MT;
		}
"<"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return LT;
		}
">="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return MTE;
		}
"<="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return LTE;
		}
"=="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return EQ;
		}
"!="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return NE;
		}

"="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return ASGN;
		}
"+="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return ADDASGN;
		}
"-="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return SUBASGN;
		}
"*="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return MULASGN;
		}
"/="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return DIVASGN;
		}
"%="		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return MODASGN;
		}

"&&"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return AND;
		}
"||"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return OR;
		}
"!"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return NOT;
		}

"("		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return LB;
		}
")"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return RB;
		}
"{"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return LCB;
		}
"}"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return RCB;
		}
"["		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return LSB;
		}
"]"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return RSB;
		}

","		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return COMMA;
		}

";"		{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return SEMICOLON;
		}
"\""		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return QUOTA;
		}

"print"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return PRINT;
		}
			
"if"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return IF;
		}
"else"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return ELSE;
		}
"for"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return FOR;
		}
"while"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return WHILE;
		}

"string"	{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return TSTRING;
		}
"int"		{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return INT;
		}
"float"		{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return FLOAT;
		}
"void"		{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return VOID;
		}
"bool"		{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return BOOL;
		}
"true"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return TRUE;
		}
"false"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return FALSE;
		}

"return"	{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return RETURN;
		}
"continue"	{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return CONTINUE;
		}
"break"		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			return BREAK;
		}

{id}		{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return ID;
		}
{Inumber}	{
			yylval.i_val = atoi(strdup(yytext));
			//printf("%s", yytext);
			strcat(buf, yytext);
			return I_CONST;
		}
{Fnumber}	{
			yylval.f_val = atof(strdup(yytext));
			//printf("%s", yytext);
			strcat(buf, yytext);
			return F_CONST;
		}
\n		{
			//printf("%s", yytext);
			strcat(buf, yytext);
			if(dealCOMMENT == 1)
			{
				int i;
				char* Ctemp = (char*)malloc(300);
				strcpy(Ctemp,"");
				for(i=0;i<strlen(buf);i++)
				{
					sprintf(Ctemp,"%s%c",Ctemp,buf[i]);
					if(buf[i] == '\n')
					{
						if(strcmp(Ctemp,"\n")==0)
						{
							printf("%d:", yylineno-line);
							line-=1;
						}
						else
						{
							printf("%d: ", yylineno-line);
							line-=1;
						}
						printf("%s", Ctemp);
						strcpy(Ctemp,"");
					}
				}
				dealCOMMENT=0;
				line=0;
			}
			else
			{
				if(strcmp(buf,"\n")==0)
				{
					printf("%d:", yylineno);
				}
				else
				{
					printf("%d: ", yylineno);
				}
				printf("%s", buf);
			}

			if(dumpSementic == 1)
			{
				sprintf(sementicErrorList[1],"%s%s",sementicErrorList[1], buf);
				printf("%s", sementicErrorList[0]);
				printf("%s", sementicErrorList[1]);
				printf("%s", sementicErrorList[2]);
				printf("%s", sementicErrorList[3]);
				dumpSementic = 0;
			}

			if(dumpOrNot == 1)
			{
				if(elseDump == 1)
				{
					dump_symbol(currentScope-1);
					elseDump = 0;
				}
				else if(elseDump == 0)
				{
					dump_symbol(currentScope);
				}
				
				currentScope -= 1;
				dumpOrNot=0;
			}
			
			if(dumpSyntax == 1)
			{
				//strcpy(syntaxErrorLine, buf);
				dumpSyntax = 0;
			}

			strcpy(buf,"");
		}
 /* C type Comment */
"/*"			{
				BEGIN COMMENT;
				dealCOMMENT=1;
				//printf("%s", yytext);
				strcat(buf, yytext);
			}
<COMMENT>[^*\n]+	{
				//printf("%s", yytext);
				strcat(buf, yytext);
			}
<COMMENT>\n		{
				//printf("%s", yytext);
				strcat(buf, yytext);
				//printf("%d: ", yylineno);
				line++;
			}
<COMMENT>"*"		{
				//printf("%s", yytext);
				strcat(buf, yytext);
			}
<COMMENT>"*/"		{
				BEGIN INITIAL;
				//printf("%s", yytext);
				strcat(buf, yytext);
			}

 /* C++ type Comment */
\/\/.*		{
			//printf("%s", yytext);
			strcat(buf, yytext);
		}

{String}	{
			yylval.string = strdup(yytext);
			//printf("%s", yytext);
			strcat(buf, yytext);
			return STRING;
		}

 /* others */
[ \t]		{
			//printf("%s", yytext);
			strcat(buf, yytext);
		}
 /* Ignore */
[^ \t\n] 	{
			//printf("%s", yytext);
			strcat(buf, yytext);
		}
 /* Ignore other charactor sets */

%%

/*	C Code section */
void keepScan()
{
	char temp;
	//temp = (char*)malloc(100);
	while(1)
	{
		temp = input();
		//printf("[%c]",temp);
		sprintf(buf, "%s%c",buf,temp);
		if(temp == '\n')
		{
			return;
		}
	}
}
int yywrap(void)
{
	return 1;
}
